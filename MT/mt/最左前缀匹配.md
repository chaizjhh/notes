[Mysql索引失效原理与最左匹配原则](https://blog.csdn.net/tc979907461/article/details/106390911)

多个列同时进行范围查找时，只有对索引最左边的那个列进行范围查找才用到B+树索引，也就是只有a用到索引，在1<a<3的范围内b是无序的，不能用索引，找到1<a<3的记录后，只能根据条件 b > 1继续逐条过滤

在没有开启索引下推的情况下，以最左边的为起点任何连续的索引都能匹配上。同时遇到范围查询(>、<、between、like)就会停止匹配。然后发生回表进行后续扫描。

在开启索引下推情况下，如果其他列都在联合索引上，则会在索引树上进行索引下推扫描，否则回表进行扫描

## 索引下推

 `use index condition`​：如果索引列上包含where条件字段，那么该字段就会到索引树上进行扫描，即使不符合最左匹配原则，where条件字段也会进行扫描

‍

1. `explain select * from fixed_suggest_config_detail where poi_id > 10000951 and sku_id >100`​

    1	SIMPLE	fixed_suggest_config_detail	null	range	idx_poi_id_sku_id	idx_poi_id_sku_id	8	null	132224	10.0	Using index condition

    在索引`idx_poi_id_sku_id`​下，即使sku_id是无序的，也会索引下推

2. `explain select * from fixed_suggest_config_detail where poi_id > 10000951 and valid =1`​

    1	SIMPLE	fixed_suggest_config_detail	null	range	idx_poi_id_sku_id	idx_poi_id_sku_id	8	null	132224	10.0	Using index condition; Using where

    在索引`idx_poi_id_sku_id`​下，即使valid不是索引字段，也会索引下推

3. `EXPLAIN SELECT c.id, c.batch_no FROM fixed_suggest_config c  where end_time  > 1713751013667`​

    1	SIMPLE	c	null	range	idx_end_time	idx_end_time	8	null	49368	100.0	Using index condition

    在索引`idx_end_time`​下，即使只有一个索引条件，也会发生索引下推，（感觉跟回表有关系）

4. `EXPLAIN SELECT c.id FROM fixed_suggest_config c  where end_time  > 1713751013667`​

    1	SIMPLE	c	null	range	idx_end_time	idx_end_time	8	null	49368	100.0	Using where; Using index

    在索引`idx_end_time`​下，没有产生回表操作，没有发生索引下推，只扫描了索引树。Using where;与 > 范围查询有关

    (当您看到`Using Index; Using where`​它时，意味着首先使用索引来检索记录（不需要实际访问表），然后在此结果集之上完成 where 子句的过滤。)

5. `EXPLAIN SELECT c.id FROM fixed_suggest_config c  where end_time  = 1713751013667`​

    1	SIMPLE	c	null	ref	idx_end_time	idx_end_time	8	const	1	100.0	Using index

    在索引`idx_end_time`​下，没有产生回表操作，没有发生索引下推，只扫描了索引树。也没有发生using where

‍

**use index;use where与use index condition**

* **Using index condition** : where condition contains indexed and non-indexed column and the optimizer will first resolve the indexed column and will look for the rows in the table for the other condition (index push down)

  where条件包含索引列和非索引列，优化器将首先解析索引列，并在表中查找其他条件的行（索引下推）

* **Using where; Using index** : 'Using index' meaning not doing the scan of entire table. 'Using where' may still do the table scan on non-indexed column but it will use if there is any indexed column in the where condition first more like using index condition

  Using index 意味着不扫描整个表。Using where 仍然可以对非索引列执行表扫描，但如果where条件中有任何索引列，则会使用，更像是Using index condition

**总结**：Using index condition与回表有关系，在where都命中索引列的前提下，进行range查询，如果有回表，则是Using index condition，否则是Using where;Using index

**Using index condition本质上是为了优化回表次数**

## 索引列选择

[索引选择参考](https://blog.csdn.net/liuxiao723846/article/details/117388961)​

索引的选择性，也可称为数据的熵。在创建索引的时候通常要求将选择性高的列放在最前面，对于选择性不高的列甚至可以不创建索引。如果选择性不高，极端性情况下可能会扫描全部或者大多数索引，然后再回表，这个过程可能不如直接走主键索引性能高。

索引列的选择往往需要根据具体的业务场景来选择，但是需要注意的是索引的区分度越高则价值就越高，意味着对于检索的性价比就高。索引的区分度等于count(distinct 具体的列) / count(*)，表示字段不重复的比例。

唯一键的区分度是1，而对于一些状态值，性别等字段区分度往往比较低，在数据量比较大的情况下，甚至有无限接近0。假设一张表中用data_status来表示数据的状态，1-有效，2-删除，则数据的区分度为 1/500000。如果100万条数据中只有1条被删除，并且在查询数据时查找data_status = 0 的数据时，需要进行全表扫描。由于索引也是需要占用内存的，所以在内存较为有限的环境下，区分度不高的索引几乎没有意义。

‍

## SQL优化

1. 通过explain查看，sql优化就是将rows扫描行数降下去
2. 索引树的根节点，长驻在内存中
3. 区分度越大的字段，放在索引中筛选掉的数据行越多。区分度小的字段一般只会增加索引的空间。判断要不要放在索引中可以判断use where需要过滤多少行。（本质还是rows行树）

‍
