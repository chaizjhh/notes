## Extra

* **Using where**：这表明MySQL在检索行后需要在服务器层进一步过滤结果。即使使用了索引，返回的结果也可能需要根据WHERE子句中的条件进行额外的筛选。
* **Using temporary**：这表示MySQL为了执行查询，需要创建一个临时表来存储中间结果。这通常发生在排序（ORDER BY）和分组（GROUP BY）操作中，特别是当无法直接通过索引来完成这些操作时。使用临时表可能会影响查询性能，尤其是当临时表很大或者需要写入磁盘时。

* **Using index condition**：**索引条件下推（Index Condition Pushdown, ICP）** ：这是MySQL 5.6及以后版本引入的一个优化特性。它允许存储引擎在使用索引检索数据时，将WHERE子句中的一部分条件下推到存储引擎层，这样可以在索引遍历过程中过滤掉更多不符合条件的记录，从而减少上层需要处理的数据量。

  在没有ICP的情况下，当MySQL执行一个包含WHERE子句的查询时，它会使用索引来找到匹配的行，然后将这些行的数据从存储引擎层传递到MySQL服务器层，由服务器层来评估WHERE子句中的所有条件。

  ICP允许存储引擎层对索引中的列直接应用WHERE子句中的一些条件。这意味着存储引擎可以在更早的阶段过滤掉不满足条件的行，而不需要将这些行的数据传递到服务器层。这样做可以减少数据在系统各层之间的传输，减少了服务器层需要处理的数据量，从而提高了查询的效率。
* **Using index：** 索引覆盖

## ID

表示select标识符，同时表示执行顺序，也就是说id是一个查询的序列号，查询序号即为sql语句执行的顺序

1. 当id值相同时，按从上到下的顺序执行
2. 当id全部不同时，按id从大到小执行
3. 当id部分不同时，先执行id大的，id相同的，按从上到下的顺序执行

## Select_Type

表示查询类型

1. simple：表示简单的select，没有union和子查询
2. primary：最外面的查询 或者 主查询，在有子查询的语句中，最外面的select查询就是primary
3. subquery：子查询
4. union：union语句的第二个或者说是后面那一个select
5. union result：union之后的结果
6. dependent unoin：unoin 中的第二个或随后的 select 查询，依赖于外部查询的结果集
7. dependent subquery：子查询中的第一个 select 查询，依赖于外部 查询的结果集
8. derived：衍生表（5.7版本中不存在这一个）

## Type

表示按某种类型来查询，例如按照索引类型查找，按照范围查找。从最好到最差的连接类型为：const、eq_ref、ref、range、indexhe和all

1. const：表中最多有一个匹配行，const用于比较primary key 或者unique索引。因为只匹配一行数据，所以很快
2. eq_ref：多表联查时候，对于前面表中的每个行组合，从该表中只读取一行，被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的类别
3. ref：非唯一性索引扫描，对于每个来自于前面的表的记录，所有匹配的行从这张表取出。出现该连接类型的条件是： 查找条件列使用了索引而且不为主键和unique。其实，意思就是虽然使用了索引，但该索引列的值并不唯一，有重复。这样即使使用索引快速查找到了第一条数据，仍然不能停止，要进行目标值附近的小范围扫描。但它的好处是它并不需要扫全表，因为索引是有序的，即便有重复值，也是在一个非常小的范围内扫描。
4. ref_or_null：类似于ref，但是可以搜索包含null值的行，例如：select * from student where address='xxx' or address is null，需要在address建立索引。
5. index_merge：查询语句用到了一张表的多个索引时，mysql会将多个索引合并到一起
6. range：按指定范围（如in、<、>、between and等，但是前提是此字段要建立索引）来检索，很常见。如：select * from student where id < 5，id上要有索引。
7. index：全“表”扫描，但是是在索引树中扫描，通常比ALL快，因为索引文件通常比数据文件小，index扫描是通过二叉树的方式扫描，而all是扫描物理表。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）。例如：select name from student，但name字段上需要建立索引，也就是查询的字段属于索引中的字段。
8. all：全表扫描，扫描完整的物理表，此时就需要优化了。

‍

## key_len

使用索引的长度，可以用来判断联合索引使用了多少字段

‍

## rows

rows 也是一个重要的字段。MySQL 查询优化器根据统计信息，估算 SQL 要查找到结果集需要扫描读取的数据行数。

这个值非常直观显示 SQL 的效率好坏，原则上 rows 越少越好。

‍

## filtered

Filtered表示返回结果的行数占需读取行数的百分比 filtered列的值越大越好 Filtered列的值依赖于统计信息
