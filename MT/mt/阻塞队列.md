## SynchronousQueue

​`SynchronousQueue`​是一个不存储元素的阻塞队列。每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。简而言之，`SynchronousQueue`​是一个内部只能包含一个元素的队列。它支持公平访问队列（FIFO）或非公平访问队列。

### 主要特点：

* **不存储元素**：`SynchronousQueue`​没有容量，与其他`BlockingQueue`​不同，它不存储元素，每个插入操作必须等到另一个线程调用移除操作，反之亦然。
* **公平性**：可以选择公平模式和非公平模式。在公平模式下，线程会按照它们等待的顺序来访问队列。
* **适用场景**：适合传递性场景，比如在一个线程中生成了一个对象，想要把这个对象传递给另一个线程使用，`SynchronousQueue`​是一个很好的选择。

### 使用场景：

​`SynchronousQueue`​通常用于任务分配场景，适用于将任务从一个线程传递给另一个线程的场景，它更像是一种线程间一对一传递消息的机制。

### 示例代码：

```java
import java.util.concurrent.SynchronousQueue;

public class SynchronousQueueExample {
    public static void main(String[] args) {
        SynchronousQueue<String> queue = new SynchronousQueue<>();

        // 生产者线程
        new Thread(() -> {
            try {
                System.out.println("Putting...");
                queue.put("Hello World!");
                System.out.println("Put done");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();

        // 消费者线程
        new Thread(() -> {
            try {
                System.out.println("Taking...");
                String take = queue.take();
                System.out.println("Taken: " + take);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

在这个例子中，生产者线程尝试向`SynchronousQueue`​中放入一个元素，但必须等待消费者线程从中取出这个元素，生产者线程才能成功完成`put`​操作，反之亦然。

### ​​SynchronousQueue​作为线程池阻塞队列

​`SynchronousQueue`​作为线程池的阻塞队列时，具有特殊的用途。在`java.util.concurrent`​包中的`ThreadPoolExecutor`​构造函数中，可以使用`SynchronousQueue`​作为工作队列。这种配置适用于那些想要直接将任务交给线程而不保持它们等待的场景，即一个任务创建了一个线程来执行它（如果线程池中有空闲线程则直接使用）。

### 特点：

* **直接提交**：使用`SynchronousQueue`​的线程池通常采用直接提交策略。当提交一个任务时，如果有空闲线程，则立即执行任务，如果没有，则尝试创建新的线程去执行任务，如果线程数达到最大线程数，则执行拒绝策略。
* **高吞吐量**：适合执行大量的短期任务的场景，可以提高吞吐量。
* **动态线程分配**：这种配置允许线程池动态地调整线程的数量，以适应不同的工作负载。

### 示例：

```java
import java.util.concurrent.*;

public class ThreadPoolWithSynchronousQueue {
    public static void main(String[] args) {
        // 创建线程池
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
                0, // 核心线程数
                Integer.MAX_VALUE, // 最大线程数
                60L, // 线程存活时间
                TimeUnit.SECONDS,
                new SynchronousQueue<Runnable>() // 使用SynchronousQueue作为工作队列
        );

        // 提交任务
        executor.execute(() -> {
            System.out.println("任务执行：" + Thread.currentThread().getName());
        });

        // 关闭线程池
        executor.shutdown();
    }
}
```

在这个示例中，线程池使用`SynchronousQueue`​作为工作队列，核心线程数为0，最大线程数为`Integer.MAX_VALUE`​，这意味着，如果有任务提交，而线程池中没有空闲线程，线程池会尝试创建新的线程去执行提交的任务。由于`SynchronousQueue`​不保持任务，每个插入操作必须等待另一个线程的移除操作，这种配置适合执行大量的短期异步任务。

使用`SynchronousQueue`​作为线程池的工作队列时，需要谨慎处理任务提交和执行策略，以避免创建过多的线程导致系统资源耗尽。

‍
