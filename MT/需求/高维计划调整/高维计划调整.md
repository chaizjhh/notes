## 生产数据接口调整

​`com.sankuai.mall.mds.gateway.HighLevelAdjustGateway#getHighDimensionSales`​

1. 从数据库表（新创建的结构）查询每个城市每个品类每天的数据
2. 将品类转换为城市纬度 换算为比例
3. 存储数据库表

```java
    // 调用算法接口获取每个品类的数据。map的key为品类ID，值为每个品类id在请求计算日期内的销量
	public Map<Long, HighDimensionalForecastSale> getHighDimensionSales(long mgCityId, List<LocalDate> reqDates) {
		// innerGetHighDimensionSales为调用RPC接口，根据不同的Request获取不同的数据 
        HighDimQueryRequest request = new HighDimQueryRequest()
                .setMgCityId(mgCityId)
                .setReqDates(reqDates.stream().map(DateTool.DTF::format).collect(Collectors.toList()))
                .setReqType(QUERY_TYPE_GET_ALL_DATA);
		// reqDate用于校验算法是否返回了正确的数据 mgCityId用于在异常时打印日志
        return this.buildHdForecastSale(
                this.innerGetHighDimensionSales(request).getCategoryDailyPcsList(),reqDates, mgCityId
        );
    }
```

```java
// 算法返回数据结构
public class HighDimensionalForecastSale {

    /**当categoryId=0即表示城市总量维度.*/
    public static final long CATEGORY_ID_SYMBOL_OF_MANAGEMENT_CITY = 0;
    /**品类ID, 当表示城市总量为0*/
    private Long categoryId;
    /**数据类型*/
    private Type type;
    /**by天的pcs数量, key=日期, 格式yyyy-MM-dd*/
    private Map<String, BigDecimal> dailyPcsMap = Maps.newHashMap();	// json
    public enum Type {
        CITY, CATEGORY2, CATEGORY3
    }
}
```

**上层调用过程**

```java
	// 拉取算法数据 示例调用处
	Map<Long, HighDimensionalForecastSale> saleMap = highLevelAdjustGateway.getHighDimensionSales(
	        managementCityId, getLatestWeekDates()
	);
	if (MapUtils.isEmpty(saleMap)) {throw new BusinessException("算法侧返回的高维预测数据为空");}
	// 持久化
	// 分布式锁 锁两分钟 锁的维度为cityId
	runTaskExclusivity(managementCityId, () -> {
		// 持久化任务
	    highDimensionalPlanRepository.combineInsertCategoryPlanPo(
	            versionPo, this.buildPlanPo(managementCityId, saleMap)	// buildPlanPro用于将品类销量转换为百分比 并构建为数据库PO结构
	    );
	});
```

**持久化任务**

```java
    public void combineInsertCategoryPlanPo(HighDimensionalAdjustVersionPO versionPo, List<HighDimensionalCategoryPlanPO> pos) {
        if (CollectionUtils.isEmpty(pos)) {
            return;
        }
        HighDimensionalPlanRepository repository = getAopProxy();
        CompletableFuture<Void> f1 = CompletableFuture.runAsync(() -> {
            // 存储主体数据表
            repository.batchInsertCategoryPlan(pos);
        });
        CompletableFuture<Void> f2 = CompletableFuture.runAsync(() -> {
            // 存储版本和快照表
            repository.combineInsertSnapshotPo(
                    versionPo,
                    pos.stream().map(this::build).collect(Collectors.toList())
            );
        });
        CompletableFuture.allOf(f1, f2).join();
    }
```

## 获取版本号

​`com.sankuai.mall.mds.service.highdimension.HighDimensionalPlanService#getLatestBiVersion`​

从redis中获取版本号

## 获取对外数据接口调整

​`com.sankuai.mall.mds.tservice.impl.HighDimensionalPlanTServiceImpl#getLatestVersionDetails`​

1. 每个城市查询最新版本号 查询high_dimensional_adjust_version表，orderById 获取最新的版本ID
2. 获取每个城市 品类的维度的量
3. 筛选出锁定日期的数据返回

该接口作为一个`thirft`​接口，主要业务实现为​​

```java
// com.sankuai.mall.mds.service.highdimension.HighDimensionalPlanService#getLatestVersionDetails
/**
 * 算法侧获取最新的人工调整明细数据
 */
public HighDimensionalQuantityDetailResponse getLatestVersionDetails(long managementCityId) {
    // 获取最新的人工干预版本 对应步骤1
    HighDimensionalAdjustVersionPO versionPO = highDimensionalPlanRepository.selectLastedVersion(
            managementCityId, LocalDate.now()
    );
    if (Objects.isNull(versionPO)) {
        return new HighDimensionalQuantityDetailResponse(Constants.SUCCESS, "", managementCityId,
                false, "", Collections.emptyList());
    }
    // 用版本ID获取快照 对应步骤2
    List<HighDimensionalCategorySnapshotDTO> snapshotList = highDimensionalPlanRepository.selectSpecialAlgorithmSnapshot(
            versionPO.getId(), null
    );
    if (CollectionUtils.isEmpty(snapshotList)) {
        // 有版本号但没有快照, 属于异常情况
        log.error("高维计划调整, 存在版本ID={}, 快照明细为空", versionPO, new BusinessException(""));
        return new HighDimensionalQuantityDetailResponse(Constants.SUCCESS, "", managementCityId,
                false, "", Collections.emptyList());
    }
    // 构建返回值
    return new HighDimensionalQuantityDetailResponse(
            Constants.SUCCESS, "", managementCityId,
            true, versionPO.getNumber(),
            this.buildQuantityDetail(snapshotList) // 品类维度比例转换为建议量
    );
}
```

品类维度比例转换为建议量，只返回三级品类的建议量

```java
private List<HighDimensionalQuantityDetail> buildQuantityDetail(List<HighDimensionalCategorySnapshotDTO> snapshotList) {
        HighDimensionalCategorySnapshotDTO cityDto = null;
        List<HighDimensionalCategorySnapshotDTO> category2DtoList = Lists.newArrayList();
        Map<Long/*二级品类ID*/, List<HighDimensionalCategorySnapshotDTO>> category3DtoMap = Maps.newHashMap();
        // 分发各个类型的快照
        for (HighDimensionalCategorySnapshotDTO dto : snapshotList) {
            HighDimensionalPlanStorageTypeEnum type = of(dto.getStorageType());
            if (MANAGEMENT_CITY == type) {
                cityDto = dto;
            } else if (CATEGORY_SECOND == type) {
                category2DtoList.add(dto);
            } else if (CATEGORY_THIRD == type) {
                category3DtoMap.computeIfAbsent(dto.getParentCategoryId(), k -> Lists.newArrayList())
                        .add(dto);
            }
        }
        if (Objects.isNull(cityDto)) {
            throw new BusinessException("数据不完整, 缺少城市总量");
        }
        // 可调整的日期 T+1 ~ T+7
        List<Pair<LocalDate, String>> adjustableDateList = getAdjustableDateListNew();
        // 与锁定日期取交集
        // 由二级品类得到pcs总量, 再划分给该品类旗下的各个三级品类
        List<HighDimensionalQuantityDetail> retList = Lists.newArrayList();
        for (HighDimensionalCategorySnapshotDTO category2Dto : category2DtoList) {
            for (Pair<LocalDate, String> datePair : adjustableDateList) {
                LocalDate date = datePair.getLeft();
                // 城市总量
                BigDecimal cityQuantity = new BigDecimal(cityDto.getDailyRatioMap().getOrDefault(date, "0"));
                // 二级品类占比
                BigDecimal category2Ratio = new BigDecimal(category2Dto.getDailyRatioMap().getOrDefault(date, "0"))
                        .divide(ONE_HUNDRED, 4, RoundingMode.HALF_UP);
                // 二级品类总的调整PCS和 = 城市总量 * 二级品类占比
                BigDecimal category2Quantity = cityQuantity.multiply(category2Ratio);
                // 三级品类的调整PCS数量 = 二级品类调整PCS和 * 三级品类占比
                List<HighDimensionalCategorySnapshotDTO> category3DtoList = category3DtoMap.getOrDefault(
                        category2Dto.getCategoryId(), Collections.emptyList()
                );
                for (HighDimensionalCategorySnapshotDTO category3Dto : category3DtoList) {
                    BigDecimal category3Ratio = new BigDecimal(category3Dto.getDailyRatioMap().getOrDefault(date, "0"))
                            .divide(ONE_HUNDRED, 4, RoundingMode.HALF_UP);
                    String category3Quantity = category2Quantity.multiply(category3Ratio)
                            .setScale(2, RoundingMode.HALF_UP)
                            .toPlainString();
                    retList.add(
                            new HighDimensionalQuantityDetail(datePair.getRight(), category3Dto.getCategoryId(), category3Quantity)
                    );
                }
            }
        }
        return retList;
    }
```

‍

## 数据库结构

​![image](assets/image-20240411154106-6vgnrue.png)​

## 数据流转

​`high_dimensional_category_snapshot`​与`high_dimensional_adjust_version`​存储版本的数据。通过`mg_city_id`​关联`version_id`​，通过`version_id`​关联快照

​`high_dimensional_category_plan`​:作为拉取的基准版本数据，`unique (create_date, mg_city_id, category_id)`​为唯一索引，数据处理逻辑为有就更新，没有就进行插入

​`high_dimensional_day_lock`​: 锁定当前城市在某一天的某个品类的份量。其中`unique (mg_city_id, category_id, plan_date)`​为唯一索引。

## 数据接口

https://ip:prot/api/m/mds/test/highDimension/refresh/algorithmNew?mgCityId=351

‍
